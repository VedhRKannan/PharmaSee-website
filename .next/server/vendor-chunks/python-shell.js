"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/python-shell";
exports.ids = ["vendor-chunks/python-shell"];
exports.modules = {

/***/ "(rsc)/./node_modules/python-shell/index.js":
/*!********************************************!*\
  !*** ./node_modules/python-shell/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.PythonShell = exports.NewlineTransformer = exports.PythonShellErrorWithLogs = exports.PythonShellError = void 0;\r\nconst events_1 = __webpack_require__(/*! events */ \"events\");\r\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\r\nconst os_1 = __webpack_require__(/*! os */ \"os\");\r\nconst path_1 = __webpack_require__(/*! path */ \"path\");\r\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\r\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\r\nconst util_1 = __webpack_require__(/*! util */ \"util\");\r\nfunction toArray(source) {\r\n    if (typeof source === 'undefined' || source === null) {\r\n        return [];\r\n    }\r\n    else if (!Array.isArray(source)) {\r\n        return [source];\r\n    }\r\n    return source;\r\n}\r\n/**\r\n * adds arguments as properties to obj\r\n */\r\nfunction extend(obj, ...args) {\r\n    Array.prototype.slice.call(arguments, 1).forEach(function (source) {\r\n        if (source) {\r\n            for (let key in source) {\r\n                obj[key] = source[key];\r\n            }\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * gets a random int from 0-10000000000\r\n */\r\nfunction getRandomInt() {\r\n    return Math.floor(Math.random() * 10000000000);\r\n}\r\nconst execPromise = (0, util_1.promisify)(child_process_1.exec);\r\nclass PythonShellError extends Error {\r\n}\r\nexports.PythonShellError = PythonShellError;\r\nclass PythonShellErrorWithLogs extends PythonShellError {\r\n}\r\nexports.PythonShellErrorWithLogs = PythonShellErrorWithLogs;\r\n/**\r\n * Takes in a string stream and emits batches seperated by newlines\r\n */\r\nclass NewlineTransformer extends stream_1.Transform {\r\n    _transform(chunk, encoding, callback) {\r\n        let data = chunk.toString();\r\n        if (this._lastLineData)\r\n            data = this._lastLineData + data;\r\n        const lines = data.split(os_1.EOL);\r\n        this._lastLineData = lines.pop();\r\n        //@ts-ignore this works, node ignores the encoding if it's a number\r\n        lines.forEach(this.push.bind(this));\r\n        callback();\r\n    }\r\n    _flush(done) {\r\n        if (this._lastLineData)\r\n            this.push(this._lastLineData);\r\n        this._lastLineData = null;\r\n        done();\r\n    }\r\n}\r\nexports.NewlineTransformer = NewlineTransformer;\r\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @param [stdoutSplitter] Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n * @param [stderrSplitter] Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n * @constructor\r\n */\r\nclass PythonShell extends events_1.EventEmitter {\r\n    /**\r\n     * spawns a python process\r\n     * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n     * @param options\r\n     * @param stdoutSplitter Optional. Splits stdout into chunks, defaulting to splitting into newline-seperated lines\r\n     * @param stderrSplitter Optional. splits stderr into chunks, defaulting to splitting into newline-seperated lines\r\n     */\r\n    constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {\r\n        super();\r\n        /**\r\n         * returns either pythonshell func (if val string) or custom func (if val Function)\r\n         */\r\n        function resolve(type, val) {\r\n            if (typeof val === 'string') {\r\n                // use a built-in function using its name\r\n                return PythonShell[type][val];\r\n            }\r\n            else if (typeof val === 'function') {\r\n                // use a custom function\r\n                return val;\r\n            }\r\n        }\r\n        if (scriptPath.trim().length == 0)\r\n            throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\r\n        let self = this;\r\n        let errorData = '';\r\n        events_1.EventEmitter.call(this);\r\n        options = extend({}, PythonShell.defaultOptions, options);\r\n        let pythonPath;\r\n        if (!options.pythonPath) {\r\n            pythonPath = PythonShell.defaultPythonPath;\r\n        }\r\n        else\r\n            pythonPath = options.pythonPath;\r\n        let pythonOptions = toArray(options.pythonOptions);\r\n        let scriptArgs = toArray(options.args);\r\n        this.scriptPath = (0, path_1.join)(options.scriptPath || '', scriptPath);\r\n        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);\r\n        this.mode = options.mode || 'text';\r\n        this.formatter = resolve('format', options.formatter || this.mode);\r\n        this.parser = resolve('parse', options.parser || this.mode);\r\n        // We don't expect users to ever format stderr as JSON so we default to text mode\r\n        this.stderrParser = resolve('parse', options.stderrParser || 'text');\r\n        this.terminated = false;\r\n        this.childProcess = (0, child_process_1.spawn)(pythonPath, this.command, options);\r\n        ['stdout', 'stdin', 'stderr'].forEach(function (name) {\r\n            self[name] = self.childProcess[name];\r\n            self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\r\n        });\r\n        // Node buffers stdout&stderr in batches regardless of newline placement\r\n        // This is troublesome if you want to recieve distinct individual messages\r\n        // for example JSON parsing breaks if it recieves partial JSON\r\n        // so we use newlineTransformer to emit each batch seperated by newline\r\n        if (this.parser && this.stdout) {\r\n            if (!stdoutSplitter)\r\n                stdoutSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stdoutSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stdout.pipe(stdoutSplitter).on('data', (chunk) => {\r\n                this.emit('message', self.parser(chunk));\r\n            });\r\n        }\r\n        // listen to stderr and emit errors for incoming data\r\n        if (this.stderrParser && this.stderr) {\r\n            if (!stderrSplitter)\r\n                stderrSplitter = new NewlineTransformer();\r\n            // note that setting the encoding turns the chunk into a string\r\n            stderrSplitter.setEncoding(options.encoding || 'utf8');\r\n            this.stderr.pipe(stderrSplitter).on('data', (chunk) => {\r\n                this.emit('stderr', self.stderrParser(chunk));\r\n            });\r\n        }\r\n        if (this.stderr) {\r\n            this.stderr.on('data', function (data) {\r\n                errorData += '' + data;\r\n            });\r\n            this.stderr.on('end', function () {\r\n                self.stderrHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stderrHasEnded = true;\r\n        }\r\n        if (this.stdout) {\r\n            this.stdout.on('end', function () {\r\n                self.stdoutHasEnded = true;\r\n                terminateIfNeeded();\r\n            });\r\n        }\r\n        else {\r\n            self.stdoutHasEnded = true;\r\n        }\r\n        this.childProcess.on('error', function (err) {\r\n            self.emit('error', err);\r\n        });\r\n        this.childProcess.on('exit', function (code, signal) {\r\n            self.exitCode = code;\r\n            self.exitSignal = signal;\r\n            terminateIfNeeded();\r\n        });\r\n        function terminateIfNeeded() {\r\n            if (!self.stderrHasEnded || !self.stdoutHasEnded || (self.exitCode == null && self.exitSignal == null))\r\n                return;\r\n            let err;\r\n            if (self.exitCode && self.exitCode !== 0) {\r\n                if (errorData) {\r\n                    err = self.parseError(errorData);\r\n                }\r\n                else {\r\n                    err = new PythonShellError('process exited with code ' + self.exitCode);\r\n                }\r\n                err = extend(err, {\r\n                    executable: pythonPath,\r\n                    options: pythonOptions.length ? pythonOptions : null,\r\n                    script: self.scriptPath,\r\n                    args: scriptArgs.length ? scriptArgs : null,\r\n                    exitCode: self.exitCode\r\n                });\r\n                // do not emit error if only a callback is used\r\n                if (self.listeners('pythonError').length || !self._endCallback) {\r\n                    self.emit('pythonError', err);\r\n                }\r\n            }\r\n            self.terminated = true;\r\n            self.emit('close');\r\n            self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\r\n        }\r\n        ;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns rejects promise w/ string error output if syntax failure\r\n     */\r\n    static checkSyntax(code) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const randomInt = getRandomInt();\r\n            const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;\r\n            const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);\r\n            return writeFilePromise(filePath, code).then(() => {\r\n                return this.checkSyntaxFile(filePath);\r\n            });\r\n        });\r\n    }\r\n    static getPythonPath() {\r\n        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\r\n    }\r\n    /**\r\n     * checks syntax without executing code\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */\r\n    static checkSyntaxFile(filePath) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const pythonPath = this.getPythonPath();\r\n            let compileCommand = `${pythonPath} -m py_compile ${filePath}`;\r\n            return execPromise(compileCommand);\r\n        });\r\n    }\r\n    /**\r\n     * Runs a Python script and returns collected messages as a promise.\r\n     * If the promise is rejected, the err will probably be of type PythonShellErrorWithLogs\r\n     * @param scriptPath   The path to the script to execute\r\n     * @param options  The execution options\r\n     */\r\n    static run(scriptPath, options) {\r\n        return new Promise((resolve, reject) => {\r\n            let pyshell = new PythonShell(scriptPath, options);\r\n            let output = [];\r\n            pyshell.on('message', function (message) {\r\n                output.push(message);\r\n            }).end(function (err) {\r\n                if (err) {\r\n                    err.logs = output;\r\n                    reject(err);\r\n                }\r\n                else\r\n                    resolve(output);\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    /**\r\n     * Runs the inputted string of python code and returns collected messages as a promise. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param code   The python code to execute\r\n     * @param options  The execution options\r\n     * @return a promise with the output from the python script\r\n     */\r\n    static runString(code, options) {\r\n        // put code in temp file\r\n        const randomInt = getRandomInt();\r\n        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;\r\n        (0, fs_1.writeFileSync)(filePath, code);\r\n        return PythonShell.run(filePath, options);\r\n    }\r\n    ;\r\n    static getVersion(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return execPromise(pythonPath + \" --version\");\r\n    }\r\n    static getVersionSync(pythonPath) {\r\n        if (!pythonPath)\r\n            pythonPath = this.getPythonPath();\r\n        return (0, child_process_1.execSync)(pythonPath + \" --version\").toString();\r\n    }\r\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */\r\n    parseError(data) {\r\n        let text = '' + data;\r\n        let error;\r\n        if (/^Traceback/.test(text)) {\r\n            // traceback data is available\r\n            let lines = text.trim().split(os_1.EOL);\r\n            let exception = lines.pop();\r\n            error = new PythonShellError(exception);\r\n            error.traceback = data;\r\n            // extend stack trace\r\n            error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\r\n            error.stack += lines.slice(1).join(os_1.EOL + '  ');\r\n        }\r\n        else {\r\n            // otherwise, create a simpler error with stderr contents\r\n            error = new PythonShellError(text);\r\n        }\r\n        return error;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    send(message) {\r\n        if (!this.stdin)\r\n            throw new Error(\"stdin not open for writing\");\r\n        let data = this.formatter ? this.formatter(message) : message;\r\n        if (this.mode !== 'binary')\r\n            data += os_1.EOL;\r\n        this.stdin.write(data);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Closes the stdin stream. Unless python is listening for stdin in a loop\r\n     * this should cause the process to finish its work and close.\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    end(callback) {\r\n        if (this.childProcess.stdin) {\r\n            this.childProcess.stdin.end();\r\n        }\r\n        this._endCallback = callback;\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Sends a kill signal to the process\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\r\n    kill(signal) {\r\n        this.terminated = this.childProcess.kill(signal);\r\n        return this;\r\n    }\r\n    ;\r\n    /**\r\n     * Alias for kill.\r\n     * @deprecated\r\n     */\r\n    terminate(signal) {\r\n        // todo: remove this next breaking release\r\n        return this.kill(signal);\r\n    }\r\n}\r\nexports.PythonShell = PythonShell;\r\n// starting 2020 python2 is deprecated so we choose 3 as default\r\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"python\";\r\nPythonShell.defaultOptions = {}; //allow global overrides for options\r\n// built-in formatters\r\nPythonShell.format = {\r\n    text: function toText(data) {\r\n        if (!data)\r\n            return '';\r\n        else if (typeof data !== 'string')\r\n            return data.toString();\r\n        return data;\r\n    },\r\n    json: function toJson(data) {\r\n        return JSON.stringify(data);\r\n    }\r\n};\r\n//built-in parsers\r\nPythonShell.parse = {\r\n    text: function asText(data) {\r\n        return data;\r\n    },\r\n    json: function asJson(data) {\r\n        return JSON.parse(data);\r\n    }\r\n};\r\n;\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHl0aG9uLXNoZWxsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRywwQkFBMEIsR0FBRyxnQ0FBZ0MsR0FBRyx3QkFBd0I7QUFDOUcsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsb0NBQWU7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGNBQUk7QUFDekIsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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ZHVsZXMvcHl0aG9uLXNoZWxsL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5QeXRob25TaGVsbCA9IGV4cG9ydHMuTmV3bGluZVRyYW5zZm9ybWVyID0gZXhwb3J0cy5QeXRob25TaGVsbEVycm9yV2l0aExvZ3MgPSBleHBvcnRzLlB5dGhvblNoZWxsRXJyb3IgPSB2b2lkIDA7XHJcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcclxuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XHJcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XHJcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XHJcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XHJcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xyXG5mdW5jdGlvbiB0b0FycmF5KHNvdXJjZSkge1xyXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICd1bmRlZmluZWQnIHx8IHNvdXJjZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICByZXR1cm4gW3NvdXJjZV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc291cmNlO1xyXG59XHJcbi8qKlxyXG4gKiBhZGRzIGFyZ3VtZW50cyBhcyBwcm9wZXJ0aWVzIHRvIG9ialxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgLi4uYXJncykge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYmo7XHJcbn1cclxuLyoqXHJcbiAqIGdldHMgYSByYW5kb20gaW50IGZyb20gMC0xMDAwMDAwMDAwMFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZG9tSW50KCkge1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKTtcclxufVxyXG5jb25zdCBleGVjUHJvbWlzZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShjaGlsZF9wcm9jZXNzXzEuZXhlYyk7XHJcbmNsYXNzIFB5dGhvblNoZWxsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbn1cclxuZXhwb3J0cy5QeXRob25TaGVsbEVycm9yID0gUHl0aG9uU2hlbGxFcnJvcjtcclxuY2xhc3MgUHl0aG9uU2hlbGxFcnJvcldpdGhMb2dzIGV4dGVuZHMgUHl0aG9uU2hlbGxFcnJvciB7XHJcbn1cclxuZXhwb3J0cy5QeXRob25TaGVsbEVycm9yV2l0aExvZ3MgPSBQeXRob25TaGVsbEVycm9yV2l0aExvZ3M7XHJcbi8qKlxyXG4gKiBUYWtlcyBpbiBhIHN0cmluZyBzdHJlYW0gYW5kIGVtaXRzIGJhdGNoZXMgc2VwZXJhdGVkIGJ5IG5ld2xpbmVzXHJcbiAqL1xyXG5jbGFzcyBOZXdsaW5lVHJhbnNmb3JtZXIgZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xyXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBjaHVuay50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0TGluZURhdGEpXHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9sYXN0TGluZURhdGEgKyBkYXRhO1xyXG4gICAgICAgIGNvbnN0IGxpbmVzID0gZGF0YS5zcGxpdChvc18xLkVPTCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdExpbmVEYXRhID0gbGluZXMucG9wKCk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlIHRoaXMgd29ya3MsIG5vZGUgaWdub3JlcyB0aGUgZW5jb2RpbmcgaWYgaXQncyBhIG51bWJlclxyXG4gICAgICAgIGxpbmVzLmZvckVhY2godGhpcy5wdXNoLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgICBfZmx1c2goZG9uZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0TGluZURhdGEpXHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9sYXN0TGluZURhdGEpO1xyXG4gICAgICAgIHRoaXMuX2xhc3RMaW5lRGF0YSA9IG51bGw7XHJcbiAgICAgICAgZG9uZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTmV3bGluZVRyYW5zZm9ybWVyID0gTmV3bGluZVRyYW5zZm9ybWVyO1xyXG4vKipcclxuICogQW4gaW50ZXJhY3RpdmUgUHl0aG9uIHNoZWxsIGV4Y2hhbmdpbmcgZGF0YSB0aHJvdWdoIHN0ZGlvXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgICAgVGhlIHB5dGhvbiBzY3JpcHQgdG8gZXhlY3V0ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBsYXVuY2ggb3B0aW9ucyAoYWxzbyBwYXNzZWQgdG8gY2hpbGRfcHJvY2Vzcy5zcGF3bilcclxuICogQHBhcmFtIFtzdGRvdXRTcGxpdHRlcl0gT3B0aW9uYWwuIFNwbGl0cyBzdGRvdXQgaW50byBjaHVua3MsIGRlZmF1bHRpbmcgdG8gc3BsaXR0aW5nIGludG8gbmV3bGluZS1zZXBlcmF0ZWQgbGluZXNcclxuICogQHBhcmFtIFtzdGRlcnJTcGxpdHRlcl0gT3B0aW9uYWwuIHNwbGl0cyBzdGRlcnIgaW50byBjaHVua3MsIGRlZmF1bHRpbmcgdG8gc3BsaXR0aW5nIGludG8gbmV3bGluZS1zZXBlcmF0ZWQgbGluZXNcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBQeXRob25TaGVsbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XHJcbiAgICAvKipcclxuICAgICAqIHNwYXducyBhIHB5dGhvbiBwcm9jZXNzXHJcbiAgICAgKiBAcGFyYW0gc2NyaXB0UGF0aCBwYXRoIHRvIHNjcmlwdC4gUmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnkgb3Igb3B0aW9ucy5zY3JpcHRGb2xkZXIgaWYgc3BlY2lmaWVkXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHN0ZG91dFNwbGl0dGVyIE9wdGlvbmFsLiBTcGxpdHMgc3Rkb3V0IGludG8gY2h1bmtzLCBkZWZhdWx0aW5nIHRvIHNwbGl0dGluZyBpbnRvIG5ld2xpbmUtc2VwZXJhdGVkIGxpbmVzXHJcbiAgICAgKiBAcGFyYW0gc3RkZXJyU3BsaXR0ZXIgT3B0aW9uYWwuIHNwbGl0cyBzdGRlcnIgaW50byBjaHVua3MsIGRlZmF1bHRpbmcgdG8gc3BsaXR0aW5nIGludG8gbmV3bGluZS1zZXBlcmF0ZWQgbGluZXNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2NyaXB0UGF0aCwgb3B0aW9ucywgc3Rkb3V0U3BsaXR0ZXIgPSBudWxsLCBzdGRlcnJTcGxpdHRlciA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHJldHVybnMgZWl0aGVyIHB5dGhvbnNoZWxsIGZ1bmMgKGlmIHZhbCBzdHJpbmcpIG9yIGN1c3RvbSBmdW5jIChpZiB2YWwgRnVuY3Rpb24pXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZSh0eXBlLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgYSBidWlsdC1pbiBmdW5jdGlvbiB1c2luZyBpdHMgbmFtZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFB5dGhvblNoZWxsW3R5cGVdW3ZhbF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIGEgY3VzdG9tIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY3JpcHRQYXRoLnRyaW0oKS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJzY3JpcHRQYXRoIGNhbm5vdCBiZSBlbXB0eSEgWW91IG11c3QgZ2l2ZSBhIHNjcmlwdCBmb3IgcHl0aG9uIHRvIHJ1blwiKTtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbGV0IGVycm9yRGF0YSA9ICcnO1xyXG4gICAgICAgIGV2ZW50c18xLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIFB5dGhvblNoZWxsLmRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcclxuICAgICAgICBsZXQgcHl0aG9uUGF0aDtcclxuICAgICAgICBpZiAoIW9wdGlvbnMucHl0aG9uUGF0aCkge1xyXG4gICAgICAgICAgICBweXRob25QYXRoID0gUHl0aG9uU2hlbGwuZGVmYXVsdFB5dGhvblBhdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHl0aG9uUGF0aCA9IG9wdGlvbnMucHl0aG9uUGF0aDtcclxuICAgICAgICBsZXQgcHl0aG9uT3B0aW9ucyA9IHRvQXJyYXkob3B0aW9ucy5weXRob25PcHRpb25zKTtcclxuICAgICAgICBsZXQgc2NyaXB0QXJncyA9IHRvQXJyYXkob3B0aW9ucy5hcmdzKTtcclxuICAgICAgICB0aGlzLnNjcmlwdFBhdGggPSAoMCwgcGF0aF8xLmpvaW4pKG9wdGlvbnMuc2NyaXB0UGF0aCB8fCAnJywgc2NyaXB0UGF0aCk7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gcHl0aG9uT3B0aW9ucy5jb25jYXQodGhpcy5zY3JpcHRQYXRoLCBzY3JpcHRBcmdzKTtcclxuICAgICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ3RleHQnO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0dGVyID0gcmVzb2x2ZSgnZm9ybWF0Jywgb3B0aW9ucy5mb3JtYXR0ZXIgfHwgdGhpcy5tb2RlKTtcclxuICAgICAgICB0aGlzLnBhcnNlciA9IHJlc29sdmUoJ3BhcnNlJywgb3B0aW9ucy5wYXJzZXIgfHwgdGhpcy5tb2RlKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBleHBlY3QgdXNlcnMgdG8gZXZlciBmb3JtYXQgc3RkZXJyIGFzIEpTT04gc28gd2UgZGVmYXVsdCB0byB0ZXh0IG1vZGVcclxuICAgICAgICB0aGlzLnN0ZGVyclBhcnNlciA9IHJlc29sdmUoJ3BhcnNlJywgb3B0aW9ucy5zdGRlcnJQYXJzZXIgfHwgJ3RleHQnKTtcclxuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNoaWxkUHJvY2VzcyA9ICgwLCBjaGlsZF9wcm9jZXNzXzEuc3Bhd24pKHB5dGhvblBhdGgsIHRoaXMuY29tbWFuZCwgb3B0aW9ucyk7XHJcbiAgICAgICAgWydzdGRvdXQnLCAnc3RkaW4nLCAnc3RkZXJyJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBzZWxmW25hbWVdID0gc2VsZi5jaGlsZFByb2Nlc3NbbmFtZV07XHJcbiAgICAgICAgICAgIHNlbGYucGFyc2VyICYmIHNlbGZbbmFtZV0gJiYgc2VsZltuYW1lXS5zZXRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nIHx8ICd1dGY4Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTm9kZSBidWZmZXJzIHN0ZG91dCZzdGRlcnIgaW4gYmF0Y2hlcyByZWdhcmRsZXNzIG9mIG5ld2xpbmUgcGxhY2VtZW50XHJcbiAgICAgICAgLy8gVGhpcyBpcyB0cm91Ymxlc29tZSBpZiB5b3Ugd2FudCB0byByZWNpZXZlIGRpc3RpbmN0IGluZGl2aWR1YWwgbWVzc2FnZXNcclxuICAgICAgICAvLyBmb3IgZXhhbXBsZSBKU09OIHBhcnNpbmcgYnJlYWtzIGlmIGl0IHJlY2lldmVzIHBhcnRpYWwgSlNPTlxyXG4gICAgICAgIC8vIHNvIHdlIHVzZSBuZXdsaW5lVHJhbnNmb3JtZXIgdG8gZW1pdCBlYWNoIGJhdGNoIHNlcGVyYXRlZCBieSBuZXdsaW5lXHJcbiAgICAgICAgaWYgKHRoaXMucGFyc2VyICYmIHRoaXMuc3Rkb3V0KSB7XHJcbiAgICAgICAgICAgIGlmICghc3Rkb3V0U3BsaXR0ZXIpXHJcbiAgICAgICAgICAgICAgICBzdGRvdXRTcGxpdHRlciA9IG5ldyBOZXdsaW5lVHJhbnNmb3JtZXIoKTtcclxuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNldHRpbmcgdGhlIGVuY29kaW5nIHR1cm5zIHRoZSBjaHVuayBpbnRvIGEgc3RyaW5nXHJcbiAgICAgICAgICAgIHN0ZG91dFNwbGl0dGVyLnNldEVuY29kaW5nKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgdGhpcy5zdGRvdXQucGlwZShzdGRvdXRTcGxpdHRlcikub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHNlbGYucGFyc2VyKGNodW5rKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsaXN0ZW4gdG8gc3RkZXJyIGFuZCBlbWl0IGVycm9ycyBmb3IgaW5jb21pbmcgZGF0YVxyXG4gICAgICAgIGlmICh0aGlzLnN0ZGVyclBhcnNlciAmJiB0aGlzLnN0ZGVycikge1xyXG4gICAgICAgICAgICBpZiAoIXN0ZGVyclNwbGl0dGVyKVxyXG4gICAgICAgICAgICAgICAgc3RkZXJyU3BsaXR0ZXIgPSBuZXcgTmV3bGluZVRyYW5zZm9ybWVyKCk7XHJcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBzZXR0aW5nIHRoZSBlbmNvZGluZyB0dXJucyB0aGUgY2h1bmsgaW50byBhIHN0cmluZ1xyXG4gICAgICAgICAgICBzdGRlcnJTcGxpdHRlci5zZXRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nIHx8ICd1dGY4Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZXJyLnBpcGUoc3RkZXJyU3BsaXR0ZXIpLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0ZGVycicsIHNlbGYuc3RkZXJyUGFyc2VyKGNodW5rKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGRlcnIpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhICs9ICcnICsgZGF0YTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZXJyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnN0ZGVyckhhc0VuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZUlmTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2VsZi5zdGRlcnJIYXNFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0ZG91dCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZG91dC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5zdGRvdXRIYXNFbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVJZk5lZWRlZCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlbGYuc3Rkb3V0SGFzRW5kZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoaWxkUHJvY2Vzcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2hpbGRQcm9jZXNzLm9uKCdleGl0JywgZnVuY3Rpb24gKGNvZGUsIHNpZ25hbCkge1xyXG4gICAgICAgICAgICBzZWxmLmV4aXRDb2RlID0gY29kZTtcclxuICAgICAgICAgICAgc2VsZi5leGl0U2lnbmFsID0gc2lnbmFsO1xyXG4gICAgICAgICAgICB0ZXJtaW5hdGVJZk5lZWRlZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHRlcm1pbmF0ZUlmTmVlZGVkKCkge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYuc3RkZXJySGFzRW5kZWQgfHwgIXNlbGYuc3Rkb3V0SGFzRW5kZWQgfHwgKHNlbGYuZXhpdENvZGUgPT0gbnVsbCAmJiBzZWxmLmV4aXRTaWduYWwgPT0gbnVsbCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBlcnI7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmV4aXRDb2RlICYmIHNlbGYuZXhpdENvZGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvckRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBzZWxmLnBhcnNlRXJyb3IoZXJyb3JEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IG5ldyBQeXRob25TaGVsbEVycm9yKCdwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJyArIHNlbGYuZXhpdENvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXJyID0gZXh0ZW5kKGVyciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGFibGU6IHB5dGhvblBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcHl0aG9uT3B0aW9ucy5sZW5ndGggPyBweXRob25PcHRpb25zIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQ6IHNlbGYuc2NyaXB0UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBzY3JpcHRBcmdzLmxlbmd0aCA/IHNjcmlwdEFyZ3MgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXRDb2RlOiBzZWxmLmV4aXRDb2RlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBlbWl0IGVycm9yIGlmIG9ubHkgYSBjYWxsYmFjayBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5saXN0ZW5lcnMoJ3B5dGhvbkVycm9yJykubGVuZ3RoIHx8ICFzZWxmLl9lbmRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgncHl0aG9uRXJyb3InLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlbGYudGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcclxuICAgICAgICAgICAgc2VsZi5fZW5kQ2FsbGJhY2sgJiYgc2VsZi5fZW5kQ2FsbGJhY2soZXJyLCBzZWxmLmV4aXRDb2RlLCBzZWxmLmV4aXRTaWduYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGNoZWNrcyBzeW50YXggd2l0aG91dCBleGVjdXRpbmcgY29kZVxyXG4gICAgICogQHJldHVybnMgcmVqZWN0cyBwcm9taXNlIHcvIHN0cmluZyBlcnJvciBvdXRwdXQgaWYgc3ludGF4IGZhaWx1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNoZWNrU3ludGF4KGNvZGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCByYW5kb21JbnQgPSBnZXRSYW5kb21JbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSAoMCwgb3NfMS50bXBkaXIpKCkgKyBwYXRoXzEuc2VwICsgYHB5dGhvblNoZWxsU3ludGF4Q2hlY2ske3JhbmRvbUludH0ucHlgO1xyXG4gICAgICAgICAgICBjb25zdCB3cml0ZUZpbGVQcm9taXNlID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzXzEud3JpdGVGaWxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlRmlsZVByb21pc2UoZmlsZVBhdGgsIGNvZGUpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tTeW50YXhGaWxlKGZpbGVQYXRoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0UHl0aG9uUGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0T3B0aW9ucy5weXRob25QYXRoID8gdGhpcy5kZWZhdWx0T3B0aW9ucy5weXRob25QYXRoIDogdGhpcy5kZWZhdWx0UHl0aG9uUGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogY2hlY2tzIHN5bnRheCB3aXRob3V0IGV4ZWN1dGluZyBjb2RlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVqZWN0cyB3LyBzdGRlcnIgaWYgc3ludGF4IGZhaWx1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNoZWNrU3ludGF4RmlsZShmaWxlUGF0aCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHB5dGhvblBhdGggPSB0aGlzLmdldFB5dGhvblBhdGgoKTtcclxuICAgICAgICAgICAgbGV0IGNvbXBpbGVDb21tYW5kID0gYCR7cHl0aG9uUGF0aH0gLW0gcHlfY29tcGlsZSAke2ZpbGVQYXRofWA7XHJcbiAgICAgICAgICAgIHJldHVybiBleGVjUHJvbWlzZShjb21waWxlQ29tbWFuZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYSBQeXRob24gc2NyaXB0IGFuZCByZXR1cm5zIGNvbGxlY3RlZCBtZXNzYWdlcyBhcyBhIHByb21pc2UuXHJcbiAgICAgKiBJZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCwgdGhlIGVyciB3aWxsIHByb2JhYmx5IGJlIG9mIHR5cGUgUHl0aG9uU2hlbGxFcnJvcldpdGhMb2dzXHJcbiAgICAgKiBAcGFyYW0gc2NyaXB0UGF0aCAgIFRoZSBwYXRoIHRvIHRoZSBzY3JpcHQgdG8gZXhlY3V0ZVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgIFRoZSBleGVjdXRpb24gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcnVuKHNjcmlwdFBhdGgsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcHlzaGVsbCA9IG5ldyBQeXRob25TaGVsbChzY3JpcHRQYXRoLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgbGV0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgICAgICBweXNoZWxsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9KS5lbmQoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci5sb2dzID0gb3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGlucHV0dGVkIHN0cmluZyBvZiBweXRob24gY29kZSBhbmQgcmV0dXJucyBjb2xsZWN0ZWQgbWVzc2FnZXMgYXMgYSBwcm9taXNlLiBETyBOT1QgQUxMT1cgVU5UUlVTVEVEIFVTRVIgSU5QVVQgSEVSRSFcclxuICAgICAqIEBwYXJhbSBjb2RlICAgVGhlIHB5dGhvbiBjb2RlIHRvIGV4ZWN1dGVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zICBUaGUgZXhlY3V0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIG91dHB1dCBmcm9tIHRoZSBweXRob24gc2NyaXB0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBydW5TdHJpbmcoY29kZSwgb3B0aW9ucykge1xyXG4gICAgICAgIC8vIHB1dCBjb2RlIGluIHRlbXAgZmlsZVxyXG4gICAgICAgIGNvbnN0IHJhbmRvbUludCA9IGdldFJhbmRvbUludCgpO1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gb3NfMS50bXBkaXIgKyBwYXRoXzEuc2VwICsgYHB5dGhvblNoZWxsRmlsZSR7cmFuZG9tSW50fS5weWA7XHJcbiAgICAgICAgKDAsIGZzXzEud3JpdGVGaWxlU3luYykoZmlsZVBhdGgsIGNvZGUpO1xyXG4gICAgICAgIHJldHVybiBQeXRob25TaGVsbC5ydW4oZmlsZVBhdGgsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIGdldFZlcnNpb24ocHl0aG9uUGF0aCkge1xyXG4gICAgICAgIGlmICghcHl0aG9uUGF0aClcclxuICAgICAgICAgICAgcHl0aG9uUGF0aCA9IHRoaXMuZ2V0UHl0aG9uUGF0aCgpO1xyXG4gICAgICAgIHJldHVybiBleGVjUHJvbWlzZShweXRob25QYXRoICsgXCIgLS12ZXJzaW9uXCIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFZlcnNpb25TeW5jKHB5dGhvblBhdGgpIHtcclxuICAgICAgICBpZiAoIXB5dGhvblBhdGgpXHJcbiAgICAgICAgICAgIHB5dGhvblBhdGggPSB0aGlzLmdldFB5dGhvblBhdGgoKTtcclxuICAgICAgICByZXR1cm4gKDAsIGNoaWxkX3Byb2Nlc3NfMS5leGVjU3luYykocHl0aG9uUGF0aCArIFwiIC0tdmVyc2lvblwiKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYW4gZXJyb3IgdGhyb3duIGZyb20gdGhlIFB5dGhvbiBwcm9jZXNzIHRocm91Z2ggc3RkZXJyXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8QnVmZmVyfSBkYXRhIFRoZSBzdGRlcnIgY29udGVudHMgdG8gcGFyc2VcclxuICAgICAqIEByZXR1cm4ge0Vycm9yfSBUaGUgcGFyc2VkIGVycm9yIHdpdGggZXh0ZW5kZWQgc3RhY2sgdHJhY2Ugd2hlbiB0cmFjZWJhY2sgaXMgYXZhaWxhYmxlXHJcbiAgICAgKi9cclxuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xyXG4gICAgICAgIGxldCB0ZXh0ID0gJycgKyBkYXRhO1xyXG4gICAgICAgIGxldCBlcnJvcjtcclxuICAgICAgICBpZiAoL15UcmFjZWJhY2svLnRlc3QodGV4dCkpIHtcclxuICAgICAgICAgICAgLy8gdHJhY2ViYWNrIGRhdGEgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IHRleHQudHJpbSgpLnNwbGl0KG9zXzEuRU9MKTtcclxuICAgICAgICAgICAgbGV0IGV4Y2VwdGlvbiA9IGxpbmVzLnBvcCgpO1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBQeXRob25TaGVsbEVycm9yKGV4Y2VwdGlvbik7XHJcbiAgICAgICAgICAgIGVycm9yLnRyYWNlYmFjayA9IGRhdGE7XHJcbiAgICAgICAgICAgIC8vIGV4dGVuZCBzdGFjayB0cmFjZVxyXG4gICAgICAgICAgICBlcnJvci5zdGFjayArPSBvc18xLkVPTCArICcgICAgLS0tLS0gUHl0aG9uIFRyYWNlYmFjayAtLS0tLScgKyBvc18xLkVPTCArICcgICc7XHJcbiAgICAgICAgICAgIGVycm9yLnN0YWNrICs9IGxpbmVzLnNsaWNlKDEpLmpvaW4ob3NfMS5FT0wgKyAnICAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY3JlYXRlIGEgc2ltcGxlciBlcnJvciB3aXRoIHN0ZGVyciBjb250ZW50c1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBQeXRob25TaGVsbEVycm9yKHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgUHl0aG9uIHNoZWxsIHRocm91Z2ggc3RkaW5cclxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGZvcm1hdCBkYXRhIHRvIGJlIHNlbnQgdG8gdGhlIFB5dGhvbiBwcm9jZXNzXHJcbiAgICAgKiBAcmV0dXJucyB7UHl0aG9uU2hlbGx9IFRoZSBzYW1lIGluc3RhbmNlIGZvciBjaGFpbmluZyBjYWxsc1xyXG4gICAgICovXHJcbiAgICBzZW5kKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3RkaW4pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0ZGluIG5vdCBvcGVuIGZvciB3cml0aW5nXCIpO1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5mb3JtYXR0ZXIgPyB0aGlzLmZvcm1hdHRlcihtZXNzYWdlKSA6IG1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ2JpbmFyeScpXHJcbiAgICAgICAgICAgIGRhdGEgKz0gb3NfMS5FT0w7XHJcbiAgICAgICAgdGhpcy5zdGRpbi53cml0ZShkYXRhKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBzdGRpbiBzdHJlYW0uIFVubGVzcyBweXRob24gaXMgbGlzdGVuaW5nIGZvciBzdGRpbiBpbiBhIGxvb3BcclxuICAgICAqIHRoaXMgc2hvdWxkIGNhdXNlIHRoZSBwcm9jZXNzIHRvIGZpbmlzaCBpdHMgd29yayBhbmQgY2xvc2UuXHJcbiAgICAgKiBAcmV0dXJucyB7UHl0aG9uU2hlbGx9IFRoZSBzYW1lIGluc3RhbmNlIGZvciBjaGFpbmluZyBjYWxsc1xyXG4gICAgICovXHJcbiAgICBlbmQoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZFByb2Nlc3Muc3RkaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZFByb2Nlc3Muc3RkaW4uZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIGEga2lsbCBzaWduYWwgdG8gdGhlIHByb2Nlc3NcclxuICAgICAqIEByZXR1cm5zIHtQeXRob25TaGVsbH0gVGhlIHNhbWUgaW5zdGFuY2UgZm9yIGNoYWluaW5nIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGtpbGwoc2lnbmFsKSB7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gdGhpcy5jaGlsZFByb2Nlc3Mua2lsbChzaWduYWwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3Iga2lsbC5cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHRlcm1pbmF0ZShzaWduYWwpIHtcclxuICAgICAgICAvLyB0b2RvOiByZW1vdmUgdGhpcyBuZXh0IGJyZWFraW5nIHJlbGVhc2VcclxuICAgICAgICByZXR1cm4gdGhpcy5raWxsKHNpZ25hbCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5QeXRob25TaGVsbCA9IFB5dGhvblNoZWxsO1xyXG4vLyBzdGFydGluZyAyMDIwIHB5dGhvbjIgaXMgZGVwcmVjYXRlZCBzbyB3ZSBjaG9vc2UgMyBhcyBkZWZhdWx0XHJcblB5dGhvblNoZWxsLmRlZmF1bHRQeXRob25QYXRoID0gcHJvY2Vzcy5wbGF0Zm9ybSAhPSBcIndpbjMyXCIgPyBcInB5dGhvbjNcIiA6IFwicHl0aG9uXCI7XHJcblB5dGhvblNoZWxsLmRlZmF1bHRPcHRpb25zID0ge307IC8vYWxsb3cgZ2xvYmFsIG92ZXJyaWRlcyBmb3Igb3B0aW9uc1xyXG4vLyBidWlsdC1pbiBmb3JtYXR0ZXJzXHJcblB5dGhvblNoZWxsLmZvcm1hdCA9IHtcclxuICAgIHRleHQ6IGZ1bmN0aW9uIHRvVGV4dChkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGpzb246IGZ1bmN0aW9uIHRvSnNvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgfVxyXG59O1xyXG4vL2J1aWx0LWluIHBhcnNlcnNcclxuUHl0aG9uU2hlbGwucGFyc2UgPSB7XHJcbiAgICB0ZXh0OiBmdW5jdGlvbiBhc1RleHQoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGpzb246IGZ1bmN0aW9uIGFzSnNvbihkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICB9XHJcbn07XHJcbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/python-shell/index.js\n");

/***/ })

};
;